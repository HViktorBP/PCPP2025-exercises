Exercise 1.2

2. Question

For describing interleaving we considered the next code:

while (true) { -- (1)
    // p.print() - but we decoded it into statements
    System.out.print("-"); -- (2)
    try { Thread.sleep(50); } catch (InterruptedException exn) { } -- (3)
    System.out.print("|"); -- (4)
}

For two dashes to appear near to each other one of the many solutions can be the next interleaving:
t1(1), t2(1), t1(2), t2(2), t1(3), t2(3), t1(4), ... ( result: --| )

And for two bars:
... t1(1), t1(2), t1(3), t2(4), t1(4) ... ( result: -|| )

3. Question
To describe why this code works perfectly we consider the next code:
For describing interleaving we considered the next code:

while (true) { -- (1)
    try {
        lock.lock(); -- (2)
        System.out.print("-"); -- (3)
        try { Thread.sleep(50); } catch (InterruptedException exn) { } -- (4)
        System.out.print("|"); -- (5)
    } finally {
        lock.lock(); -- (6)
    }
}

And lets review one of the interleavings that we previously stated (a bit modified including the operations of lock/unlock):

t1(1), t2(1), t1(2), t2(2), t1(3), t2(3), t1(4), t2(4), t1(5), ... ( result: --| )

t1(2) must be after t2(6) and t2(2) must be before t1(6). That means that program will look either like this:

t1(1), t2(1), t1(2), t1(3), t1(4), t1(5), t1(6), t2(2) ...
or
t2(1), t1(1), t2(2), t2(3), t2(4), t2(5), t2(6), t1(2) ...

The same works in case of bars.

By adding a lock, we provide an atomicity for the print method of Printer class ensuring that only one thread can use that method therefore resulting in a correct printing of the sequence.

Exercise 1.3

In our case, we have both race condition and data race in our critical section (which is { if (counter < MAX_PEOPLE_COVID) { counter++; }} ).
By adding a lock to our solution we leave an execution to this critical section only to one thread at a time.
This means that checking the value of counter and writing to it will be performed atomically by one thread (i.e. no data will be lost).