1.
    I get values of 19 million but different every time because there is a Race Condition in the program;
    The counter logic is not atomic. It means that we have shared memory, counter, that two threads are trying
    to access.
2.
    It is not guaranteed that the output is always 200.
    Because incrementation in LongCounter is not atomic, we have counter in a shared memory, thus
    Race Conditions may occur. When we use millions the chance for RC to occur is much higher than when we use 100
3.
    It will not make a difference because the counter logic is still not atomic and
    threads use shared memory. There are no differences in results as we still have a race condition in the program
4.
    I have defined a critical section in the program, it is the part that used shared memory (counter variable).
    By using .lock() and .unlock() we are ensuring that the critical section with shared memory can only be
    accessed by one thread at the same time. So we are achieving a Mutual Exclusion using lock methods.
    Thus we have established an execution order for the counter operation.
5.
    I have defined a critical section with the least amount of code, the increment operation.
    Only that part is modifying shared memory.

6.
    It verifies my answer as decomp provides similar byte code
7.
    Without using lock we will have a race condition as we had in increment() method. The problem stays the same,
    the threads are accessing shared memory and creating a race condition. Every time we will get a number of
    around -40000 +-.
    By adding a lock/unlock  around count-=1 we defined a critical section and that shared memory is accessed(modified)
    by one thread at a time.

8. TODO when we have time